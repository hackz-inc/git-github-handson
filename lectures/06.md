# こんな時どうする

## 【目次】

1. [はじめに](#はじめに)
2. [add を取り消したい](#addを取り消したい)
3. [特定のコミットまで戻したい](#特定のコミットまで戻したい)
4. [間違えてコードを reset してしまった](#間違えてコードを-reset-してしまった)
5. [間違えてマージしてしまった](#間違えてマージしてしまった)
6. [先に進んでいる別ブランチを反映させたい](#先に進んでいる別ブランチを反映させたい)
7. [コンフリクトが起きた時](#コンフリクトが起きた時)
8. [変更ファイルがあるから pull できない](#変更ファイルがあるからpullできない)
9. [間違えて別のブランチにコミットしてしまった](#間違えて別のブランチにコミットしてしまった)
10. [リモートブランチが先に進んでいる場合](#リモートブランチが先に進んでいる場合)
11. [環境変数や秘密鍵をコミットしてしまった](#環境変数や秘密鍵をコミットしてしまった)
12. [PR のコミット分けろって怒られた](#PRのコミット分けろって怒られた)
13. [さいごに](#さいごに)

## 【はじめに】

ここでは、個人開発やチーム開発などでよく起こる「こんな時どうする」ということの解決方法とコマンドの説明をしていきます。

とにかく解決したい！と言う場合にはチートシートを用意しているので、こちらをご覧ください。 // TODO: リンクを追加

## 【add を取り消したい】

まだ編集が完了していないのに、add してしまった。  
add する予定のないファイルまで add してしまった。

などなど、add を取り消したい時は少なくありません。

安心してください。add を取り消したい時には以下のコマンドを実行するだけで大丈夫です。

```bash
// 全てのadd取り消す
$ git reset HEAD
or
$ git reset

// 特定のファイルのみ取り消す
$ git reset HEAD [ファイルのパス]
or
$ git reset [ファイルのパス]
```

`reset`コマンドはデフォルトで`HEAD`が指定されるため、`HEAD`は付けても付けなくても OK です。

`HEAD`とは一言で言うならば自分が今作業をしている場所のポインタです。  
つまり、現在自分が今いるブランチの最新のコミットを表しています。

log で履歴を見てみると、現在のブランチの最新のコミットに HEAD と示されていることが確認できます。

```bash
// mainブランチでlog
$ git log
----------------------------------------------------------------------------
commit 808c1b847fbc245cd17b31122ad12140610a5cf2 (HEAD -> main, origin/main)
Merge: 527161f 87b2c04
Author: Takeru  Miki <take.cantik17@gmail.com>
Date:   Mon Dec 12 11:04:52 2022 +0900

    Merge pull request #1 from take-cantik/test-1

    hello関数の作成

commit 87b2c04297cd7a356d08899f58d1e6070e7ad7b6 (origin/test-1, test-1)
Author: take-cantik <take.cantik17@gmail.com>
Date:   Sun Dec 11 19:13:39 2022 +0900

    Update: delete test and add hello func

commit 527161f482b839ecf8658b6135a1f09f69640eab
Author: take-cantik <take.cantik17@gmail.com>
Date:   Mon Dec 5 01:19:43 2022 +0900

    Update: README
```

```bash
// test-1ブランチでlog
$ git log
----------------------------------------------------------------------------
commit 87b2c04297cd7a356d08899f58d1e6070e7ad7b6 (HEAD -> test-1, origin/test-1)
Author: take-cantik <take.cantik17@gmail.com>
Date:   Sun Dec 11 19:13:39 2022 +0900

    Update: delete test and add hello func

commit 527161f482b839ecf8658b6135a1f09f69640eab
Author: take-cantik <take.cantik17@gmail.com>
Date:   Mon Dec 5 01:19:43 2022 +0900

    Update: README

commit 7b2ea0f4d20df2a0623b2e06f74eaf7e54d1e2ed
Author: take-cantik <take.cantik17@gmail.com>
Date:   Mon Dec 5 01:19:19 2022 +0900

    Add: test func
```

次に`reset`コマンドですが、このコマンドには大きく以下の二つの機能を持ちます。

1. インデックスを任意の状態に変更
2. HEAD を指定したコミットに移動

今回は 1 番目の機能を使用しています。

つまり、

```bash
$ git reset HEAD
```

を行うと、インデックスの状態を HEAD と同じ状態に戻す。つまり、add したものが削除されると言うことになります。

ここで、注意する点があります。  
それはファイル削除の add をファイル指定で HEAD を付けずに reset しようとした時です。

ワーキングツリーにファイルがない場合にはパスが見つからないと怒られてしまいます。

```bash
$ git reset index.js
-----------------------------------------------------------------------------------------
fatal: ambiguous argument 'index.js': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git <command> [<revision>...] -- [<file>...]'
 ~/works/hackz/test/test-app
```

しかし、第二引数に`HEAD`を入れると問題なく元に戻すことができます。

```bash
$ git reset HEAD index.js
----------------------------------------
Unstaged changes after reset:
D index.js
```

なんとなくで覚えていると詰まる時もあるので、常に`HEAD`をつけることを意識するとなんの問題もありません。

また、`git init`直後の`HEAD`が存在しないタイミングでの add を取り消したい場合には以下のコマンドを実行します。

```bash
// 全てのaddを取り消す
$ git rm --cached -r .

// 特定のファイルのaddを取り消す
$ git rm --cached [ファイルのパス]
```

`rm`コマンドは、ワークツリーとインデックスからファイルを削除するコマンドです。

これを行うとファイルも消えてしまうのですが、`--cached`を指定することによりファイルをインデックスのみから削除できるようになります。  
また、`-r`を指定するとディレクトリをまとめて削除することが可能になります。

## 【特定のコミットまで戻したい】

間違えてコミットしてしまった。  
実装はしたが、コードが不要になってしまった。

など、ある場所までコミットを戻したい時があると思います。

コミットを戻す時は主に以下の２つの方法があります。

- `reset`コマンド
- `revert`コマンド

### reset コマンドでコミットを戻す

reset コマンドを使うと**コミットをなかったこと**に出来ます。  
つまり、コミット自体を削除してしまいます。  
ですのでコミットログは見やすくなると言うメリットがあります。

しかしこのやり方には注意点があります。  
リモートリポジトリに`push`したコミットに対して行うと、不具合が発生してしまいます。
コミットそのものを削除してしまうので、既に取り消したコミットの上にさらに誰かがコミットしている場合に、  
存在するはずの親コミットがなくなってしまい、push することができなくなってしまいます。

したがって、`reset`コマンドを使用する場合には、**まだリモートに push していないローカルのみのコミット、または自分しか手をつけていないブランチのコミットのみに使用**するようにしてください。

使い方は以下の通りです。

```bash
// ワークツリーとインデックスはそのままにしたい時
$ git reset --soft [戻りたいコミットのID]

// ワーキングツリーはそのままでコミットを戻したい時
$ git reset --mixed [戻りたいコミットのID]

// 全てを戻したい時
$ git reset --hard [戻りたいコミットのID]
```

コミットの ID は`log`コマンドで出力される英数字の羅列となります。

reset のオプションについては以下の通りです。

`--soft`を指定すると、コミットのみが取り消されます。  
つまり、それまでのファイルの変更や add した内容はそのままになります。  
このオプションはまだコミットする予定がないのにコミットしてしまった時や、コミットするファイルを間違えてしまった時などに使うと便利なものです。

`--mixed`を指定すると、コミットとインデックスの中身も削除します、  
ちなみにオプション指定なしだとデフォルトでこのオプションがつきます。  
add 取り消しの時に `$ git reset HEAD` をしたと思いますが、このコマンドで add が取り消されるのは最後のコミットまでインデックスも戻すからということになります。

`--hard`を指定すると、ワークツリーもインデックスも元に戻ります。  
つまり、指定したコミットをした時の状態に戻るといった感じです。  
このオプションはコミットの内容がいらなくなった時などに使用します。

### revert コマンドでコミットを戻す

コミットを戻したい時にもう 1 つのやり方として`revert`コマンドがあります。

このコマンドは、コミットと逆の内容のコミットを作成するコマンドです。  
`revert`はコミットを取り消すのではなく、逆操作のコミットを追加するだけなのでリモートへ push 済みのコミットを`revert`しても問題はありません。

`revert`のログが残るのでログが少し汚くなるというデメリットもありますが、  
`revert`の方が安全に元に戻したり、`revert`の`revert`もできるので個人的にはこちらの方がオススメです。

使い方は以下の通りです。

```bash
$ git revert [取り消したいコミットのID]
```

このコマンドを実行するとエディタが開かれるので、保存すれば OK です。

## 【間違えてマージしてしまった】

Pull Request を作成した後脳死でそのままマージをしてしまった...  
この Pull Request のマージを取り消したい  
というミスをしてしまったことがある人もいると思います。

しかし、GitHiub 上からマージ済みの Pull Request を Revert することができます。

以下のようにクローズされた Pull Request の「Revert」ボタンを選択すると、  
Pull Request を revert した Pull Request を作成することが可能です。

<img width="600" alt="スクリーンショット 2022-12-21 17 24 15" src="https://user-images.githubusercontent.com/50654077/209042656-611240fe-c449-4058-8e94-21881dc6d474.png">

<img width="600" alt="スクリーンショット 2022-12-21 17 24 28" src="https://user-images.githubusercontent.com/50654077/209042664-2c071ccf-8fa5-4ec8-8b86-da7340cf9a6d.png">

これをマージすることによって、コードを元に戻すことができます。

改めて変更点の Pull Request を出したい場合には、Revert した Pull Request をさらに Revert すれば、  
本来出したかった Pull Request と同じ内容の Pull Request を作成することが可能です。

しかし、マージした時に発火する Actions などは動いてしまいますし、ログも汚くなるので 1 番は間違えてマージしてしまわないことですね。

## 【間違えてコードを reset してしまった】

`--hard`で reset をしてしまい、コードが消えてしまった。
など間違えてリセットしてしまった場合にも解決方法はあります。

先ほど`reset`コマンドはコミット自体を削除するので、ログが残らないと言いましたが、  
`reflog`コマンドを使えば作業ログを出力することができます。

例として、

1. `README.md`の追加
2. `index.js`の追加

をやった時に、`reflog`をしてみます。

```bash
$ git reflog
-----------------------------------------------------
bde95ea (HEAD -> main) HEAD@{0}: commit: Add: index
404d1c0 HEAD@{1}: commit (initial): Add: README
```

このように自分のやった作業ログを確認できます。  
では、実際に間違って`reset`してしまったと言う体で最初のコミットまで戻って`reflog`をしてみます。

すると出力は以下のようになります。

```bash
$ git reflog
---------------------------------------------------------------
404d1c0 (HEAD -> main) HEAD@{0}: reset: moving to 404d1c0
bde95ea HEAD@{1}: commit: Add: index
404d1c0 (HEAD -> main) HEAD@{2}: commit (initial): Add: README
```

`--hard`で`reset`したため、ワークツリーにはすでに`index.js`は存在していませんし、  
`$ git log`を出しても`index.js`を追加したコミットは出力されません。

しかし`reflog`を行うと、このように`reset`を行ったという作業ログが出力されます。  
`HEAD@{n}`が作業番号ということになります。

ですので、`index.js`を追加した場所つまり、`HEAD@{1}`に戻ればいいので、

```bash
$ git reset --hard HEAD@{1}
```

をしてあげると、なんと`reset`した`index.js`を追加したコミットを復活させることができます。

実際に作業ログを改めて確認してみると、以下のように出力されます。

```bash
$ git reflog
------------------------------------------------------------
bde95ea (HEAD -> main) HEAD@{0}: reset: moving to HEAD@{1}
404d1c0 HEAD@{1}: reset: moving to 404d1c0
bde95ea (HEAD -> main) HEAD@{2}: commit: Add: index
404d1c0 HEAD@{3}: commit (initial): Add: README
```

ここで分かるように、`HEAD`の位置が最初に`reset`をした`bde95ea`になっていることが確認できます。

このように`--hard`で消してしまっても作業ログを辿れば問題なく復元させることができるので、焦らないようにしましょう。

## 【間違えてブランチを消してしまった】

作業中のブランチをまだ push していなかったのに消してしまった。

という時があるかもしれません。  
そんな時も、`reflog`コマンドを使って作業ログを確認することによって解決することができます。

例として以下の操作を行ったとします。

1. `main`ブランチで`README`の追加
2. `test-1`ブランチを作成&移動
3. `test-1`ブランチで`index.js`の追加

この操作を行って`reflog`をしてみると、

```bash
$ git reflog
--------------------------------------------------------------
58c824f (HEAD -> test-1) HEAD@{0}: commit: Add: index
4377528 (main) HEAD@{1}: checkout: moving from main to test-1
4377528 (main) HEAD@{2}: commit (initial): Add: README
```

このように出力されます。  
ここで`test-1`を消してみます。

これで`test-1`ブランチはなくなりましたが、以下のように`reflog`で`test-1`ブランチでの操作記録が残っています。

```bash
$ git reflog
--------------------------------------------------------------
4377528 (HEAD -> main) HEAD@{0}: checkout: moving from test-1 to main
58c824f HEAD@{1}: commit: Add: index
4377528 (HEAD -> main) HEAD@{2}: checkout: moving from main to test-1
4377528 (HEAD -> main) HEAD@{3}: commit (initial): Add: README
```

ここで、`branch`コマンドを使って`HEAD@{1}`を`test-1`ブランチへコピーしてみます。

```bash
$ git branch test-1 HEAD@{1}
```

ここで、ブランチを確認してみると

```bash
$ git branch
* main
  test-1
```

と、このように`test-1`ブランチが復活していることがわかります。

`branch`コマンドはブランチを作成することができますが、第 2 引数にブランチを指定すると  
そのブランチから新しいブランチを生やすことができます。

```bash
// developブランチからtest-1ブランチを生やす
$ git branch test-1 develop
```

ここで、ブランチとは実はコミットを表すポインタにすぎません。  
つまり main ブランチにいるときは`HEAD`と`main`は同じ存在であると言えます。

作業番号である`HEAD@{n}`も同様にその場所を示すポインタにすぎないので、

```bash
$ git branch test-1 HEAD@{1}
```

を行うと、`HEAD@{1}`の示す状態から`test-1`ブランチを生やしたということになり、  
`test-1`が復活したように見える、というわけです。

## 【先に進んでいる別ブランチを反映させたい】

チーム開発をしているときに、自分のブランチより先に進んでいるブランチを自分のブランチに反映させたい時があります。

そんな時は。`merge`コマンドまたは、`rebase`コマンドを使用することによって解決することができます。  
これらのコマンドはどちらもブランチ同士を統合するためのコマンドですが、統合のやり方が異なります。

よくある使い方の例としては、  
main ブランチへ Pull Request を出す前にブランチの派生元が進んでいる場合には、自分のブランチへ`main`ブランチを`rebase`して、  
そのブランチを`main`ブランチへ`merge`させるために Pull Request を作成、その後`merge`する。

といった使用方法になります。

つまり、

- 先に進んでいるブランチが反映させたいブランチの派生元であれば `rebase`
- 先に進んでいるブランチが反映させたいブランチの派生先であれば `merge`

を使用するという使い分けです。

一見この操作を二度手間のように感じるかもしれませんが、こうすることによってより安全かつログが綺麗になるように開発を進めることができます。
その理由について説明する前に、まずは`merge`と`rebase`それぞれの使い方や特徴について説明していきます。

### merge

`merge`とは元のブランチと派生させたブランチを統合させ、統合したというコミットを作成します。

例として以下の操作を行います。

1. README の作成 (main)
2. `test-1`ブランチを切る
3. `test`ファイルの作成 (test-1)
4. `test`ファイルの編集 (test-1)
5. `index`ファイルの追加 (main)

```bash
// コミットログ
* f1e3838 take-cantik  (HEAD -> main) Add: index file
| * bea436f take-cantik  (test-1) Add: console log to test
| * 7645861 take-cantik  Add: test file
|/
* d9eba18 take-cantik  Add: README
```

ここで、`main`ブランチへ`test-1`ブランチをマージしてみます。

```bash
// mainブランチにて
$ git merge test-1
```

`merge`した後にログを確認してみると、

```bash
// コミットログ
*   e7fec15 take-cantik  (HEAD -> main) Merge branch 'test-1'
|\
| * bea436f take-cantik  (test-1) Add: console log to test
| * 7645861 take-cantik  Add: test file
* | f1e3838 take-cantik  Add: index file
|/
* d9eba18 take-cantik  Add: README
```

このように、ブランチが統合されマージをしたというコミット(一番上のログ)が作成されます。

### rebse

`rebase`コマンドは実際には、コミット履歴の移動や削除を行うコマンドですが、  
別ブランチからコミットを移動させることによって、ブランチの統合を行うことができます。

ここで、例として先ほどと同じ手順で操作を行い、ログが以下のようになっているとします。

```bash
// コミットログ
* f1e3838 take-cantik  (HEAD -> main) Add: index file
| * bea436f take-cantik  (test-1) Add: console log to test
| * 7645861 take-cantik  Add: test file
|/
* d9eba18 take-cantik  Add: README
```

ログの通り、`test-1`を分岐させたタイミングの`main`より現在の`main`の方が進んでいる状態なので、  
`main`の内容を`test-1`に反映させます。

```bash
// test-1ブランチにて
$ git rebase main
```

これで、`main`の情報が`test-1`へ反映されました。  
この時のログは以下のようになります。

```bash
// コミットログ
* 83c0a55 take-cantik  (HEAD -> test-1) Add: console log to test
* 01a6be7 take-cantik  Add: test file
* f1e3838 take-cantik  (main) Add: index file
* d9eba18 take-cantik  Add: README
```

このように進んでいた`main`のコミットの上に`test-1`で行ったコミットが乗っているのがわかります。

ここで、注意して欲しいのが`test-1`で行ったコミットの ID が変わっているということです。

`rebase`を使用すると`test-1`で行ったコミットが`main`の上にコミットが移動します。  
コミットはこれまでのコミット履歴に紐付いているので、ID も変わるという仕組みになります。  
同じ内容のコミットを新たに`main`に加えると考えるといいでしょう。

先ほど、よくある使い方の例として、

> main ブランチへ Pull Request を出す前にブランチの派生元が進んでいる場合には、自分のブランチへ`main`ブランチを`rebase`して、  
> そのブランチを`main`ブランチへ`merge`させるために Pull Request を作成、その後`merge`する。
>
> 一見この操作を二度手間のように感じるかもしれませんが、こうすることによってより安全かつログが綺麗になるように開発を進めることができます。

といいましたが、実際に`main`ブランチの履歴を`rebase`で持ってきた`test-1`ブランチを`main`ブランチへ`merge`してみます。

```bash
// mainブランチにて
$ git rebase test-1
```

これを行ってログを見てみると

```bash
// rebaseを行ってmergeしたときのログ
* 83c0a55 take-cantik  (HEAD -> main, test-1) Add: console log to test
* 01a6be7 take-cantik  Add: test file
* f1e3838 take-cantik  Add: index file
* d9eba18 take-cantik  Add: README
```

これで`main`が`test-1`に追いつきましたね。  
このように、ただ`merge`した時よりログが綺麗になっていることがわかります。

```bash
// mergeのみを行った時のログ
*   e7fec15 take-cantik  (HEAD -> main) Merge branch 'test-1'
|\
| * bea436f take-cantik  (test-1) Add: console log to test
| * 7645861 take-cantik  Add: test file
* | f1e3838 take-cantik  Add: index file
|/
* d9eba18 take-cantik  Add: README
```

## 【コンフリクトが起きた時】

## 【変更ファイルがあるから pull できない】

## 【間違えて別のブランチにコミットしてしまった】

## 【リモートブランチが先に進んでいる場合】

## 【環境変数や秘密鍵をコミットしてしまった】

## 【PR のコミット分けろって怒られた】

## 【さいごに】

これ以外にもこんな場合の解決方法が欲しいという場合には、Issue に書いてください！

[前の資料](05.md) [次の資料](06.md)

```

```
